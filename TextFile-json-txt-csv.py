import csvimport jsonimport osimport unittestfrom abc import ABC, abstractmethodimport pandas as pdclass TextFile(ABC):    # receive file path as a parameter, check whether file exists, Check file type, save file path    # not loading file yet    def __init__(self, file_path):        self._delimiter = ','        self._file_path = file_path        if not os.path.exists(file_path):            raise Exception("File does not exist")        elif os.path.splitext(self._file_path)[-1][1:] != self._get_ext():            raise Exception("check the end of the file name")    # available only on CSV files and TXT, not JSON    def __add__(self, other):        # check that the other object is also an instance of TextFile        if not isinstance(other, TextFile):            raise Exception("Can only concatenate TextFile objects")        # check that the file types are CSV or TXT        if os.path.splitext(self._file_path)[-1][1:] not in ['csv', 'txt']:            raise Exception("cannot apply this method on non-csv or non-txt files.")        # read the contents of both files        content1 = self.get_content()        content2 = other.get_content()        # concatenate the contents and write them to a new file        new_file_path = f"{os.path.splitext(self._file_path[0])}_{os.path.splitext(other._file_path)[0]}"        # check that the file does not already exist        if os.path.exists(new_file_path):            raise Exception("File already exists")        # check that the file types are the same        if os.path.splitext(self._file_path)[-1][1:] != os.path.splitext(other._file_path)[-1][1:]:            raise Exception("Cannot concatenate files of different types")        # create the content for the new file        new_content = content1 + content2        # check if the file is text file:        if os.path.splitext(self._file_path)[-1][1:] == 'txt':            # write the new content to the file            with open(new_file_path, 'w') as f:                f.write(new_content)    @abstractmethod    def _get_ext(self):        pass    def get_file_size(self):        return os.path.getsize(self._file_path)    def get_content(self):        with open(self._file_path) as f:            content = self._get_specific_content(f)        return content    @abstractmethod    def _get_specific_content(self, f):        passclass CsvFile(TextFile, ABC):    def __init__(self, file_path, delimiter=','):        super().__init__(file_path)        self._delimiter = delimiter    # get_rows_num - return amount of rows in a file (int)    def get_rows_num(self):        df = pd.read_csv(self._file_path, delimiter=self._delimiter)        # return the number of rows in the DataFrame        return len(df.index)    # get_columns_num - return amount of columns in a file (int)    def get_column(self, column_num):        # read the file into a Pandas DataFrame        df = pd.read_csv(self._file_path, delimiter=self._delimiter)        # the specified column as a list of values        ret_val = df.iloc[:, column_num].tolist()        # returns the amounts of columns in a file by length        return len(ret_val)    def get_row(self, row_num):        # open the file and read the first row        with open(self._file_path, 'r') as f:            # read the first row to get the column names            first_row = f.readline()            # split the first row by the delimiter to get the column names            column_names = first_row.split(self._delimiter)            # read the rest of the rows and store them in a list            rows = []            for row in f:                rows.append(row)        # if the row number is greater than the number of rows in the file, return None        if row_num > len(rows):            return None        # split the row by the delimiter and return the values as a dictionary        # with the keys as the column names        return {column_names[i]: val for i, val in enumerate(rows[row_num].split(self._delimiter))}    def get_num_columns(self):        # open the file and read the first row        with open(self._file_path, 'r') as f:            first_row = f.readline()            return len(first_row.split(self._delimiter))    def get_cell(self, row_num, column_num):        # read the file into a Pandas DataFrame        df = pd.read_csv(self._file_path, delimiter=self._delimiter)        # return the value at the specified row and column        return df.iloc[row_num, column_num]    def _get_ext(self):        return 'csv'    def _get_specific_content(self, f):        ret_val = []        for row in csv.DictReader(f, delimiter=self._delimiter):            ret_val.append(row)        return ret_valclass TxtFile(TextFile, ABC):    def _get_ext(self):        return 'txt'    def _get_specific_content(self, f):        return f.read()    def get_words_num(self):        # open the file and read its contents        with open(self._file_path, 'r') as f:            content = f.read()        # split the content by whitespace and return the number of words        return len(content.split())    def get_avg_word_len(self):        # open the file and read its contents        with open(self._file_path, 'r') as f:            content = f.read()        # split the content by whitespace and calculate the average length of words        words = content.split()        total_len = sum(len(word) for word in words)        return total_len / len(words)class JsonFile(TextFile, ABC):    def _get_ext(self):        return 'json'    def _get_specific_content(self, f):        return json.load(f)    def is_list(self):        # open the file and read its contents        with open(self._file_path, 'r') as f:            content = json.load(f)        # check whether the content is a list and return the result        return isinstance(content, list)    def is_object(self):        # open the file and read its contents        with open(self._file_path, 'r') as f:            content = json.load(f)        # check whether the content is a dictionary and return the result        return isinstance(content, dict)# ________________________________unittests______________________________#class TestFI(unittest.TestCase):    # ________________________________init__________________________________#    def __init__(self, methodName: str):        super().__init__(methodName)    @classmethod    def setUpClass(cls) -> None:        cls.csv_file1 = CsvFile('/Users/MUGA/PycharmProjects/EDULABS/edulabs excercises/Classes practise/new_AAPL.csv')        cls.json_file1 = JsonFile('/Users/MUGA/PycharmProjects/EDULABS/edulabs excercises/Classes practise/data.json')        cls.txt_file1 = TxtFile('/Users/MUGA/PycharmProjects/EDULABS/edulabs excercises/Classes practise/data.txt')        cls.csv_file2 = CsvFile('/Users/MUGA/PycharmProjects/EDULABS/edulabs excercises/Classes practise/aaple.csv')    # __________________________test_file_size_txt____________________________#    def test2_file_size1(self):        self.assertEqual(self.txt_file1.get_file_size(), 50010)    # ___________________________test_file_size_csv__________________________________#    def test6_file_size5(self):        self.assertEqual(self.csv_file1.get_file_size(), 1169)    # ___________________________test_file_size_json__________________________________#    def test8_file_size7(self):        self.assertEqual(self.json_file1.get_file_size(), 796)    # _______________________________________________________________________#    # ________________________________CSV____________________________________#    # _______________________________________________________________________#    # ___________________________test_Csv_rows_______________________________#    def test35_rows2(self):        self.assertEqual(self.csv_file1.get_rows_num(), len(self.csv_file1.get_content()))    def test36_rows3(self):        self.assertEqual(self.csv_file2.get_rows_num(), len(self.csv_file2.get_content()))    # ___________________________test_Csv_columns_______________________________#    def test39_row1(self):        self.assertEqual(self.csv_file2.get_column(1), 18)    def test40_row2(self):        self.assertEqual(self.csv_file1.get_column(1), 17)    # _________________________test_Csv_get_cell______________________________#    def test46_by_column1(self):        self.assertEqual(self.csv_file1.get_cell(1, 1), 'asdasda')    def test48_by_column3(self):        self.assertEqual(self.csv_file2.get_cell(1, 1), 'asdfas d')    # _______________________________________________________________________#    #     ___________________________JSON_______________________________#    # _______________________________________________________________________#    # _________________________test_Json_is_list_____________________________#    def test52_is_list1(self):        self.assertEqual(self.json_file1.is_list(), False)    # _________________________test_Json_is_object_____________________________#    def test_is_object(self):        self.assertEqual(self.json_file1.is_object(), True)    # _______________________________________________________________________#    # ________________________________TXT____________________________________#    # _______________________________________________________________________#    # _______________________test_Txt_words_amount___________________________#    def test58_words_amount1(self):        self.assertEqual(self.txt_file1.get_words_num(), 9053)    # _______________________test_Txt_avg_len_of_word__________________________#    def test63_avg_word_len3(self):        self.assertEqual(self.txt_file1.get_avg_word_len(), 4.270628520932288)if __name__ == "__main__":    unittest.main()